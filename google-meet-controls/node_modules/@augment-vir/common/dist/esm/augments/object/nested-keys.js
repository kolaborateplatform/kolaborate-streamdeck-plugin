import { isRunTimeType } from 'run-time-assertions';
import { isLengthAtLeast } from '../tuple';
import { isObject } from './object';
import { typedHasProperty } from './typed-has-property';
/** This mutates the {@link originalObject} input. */
export function setValueWithNestedKeys(originalObject, nestedKeys, value) {
    /**
     * Lots of as any casts in here because these types are, under the hood, pretty complex. Since
     * the inputs and outputs of this function are well typed, these internal as any casts do not
     * affect the external API of this function.
     */
    const nestedKeysInput = nestedKeys;
    const inputObject = originalObject;
    if (isRunTimeType(inputObject, 'array')) {
        inputObject.forEach((entry) => {
            if (isObject(entry)) {
                setValueWithNestedKeys(entry, nestedKeysInput, value);
            }
        });
    }
    else if (isLengthAtLeast(nestedKeysInput, 2)) {
        /** If there are more keys to traverse into. */
        const nextKey = nestedKeysInput[0];
        if (!(nextKey in inputObject)) {
            inputObject[nextKey] = {};
        }
        const nextParent = inputObject[nextKey];
        setValueWithNestedKeys(nextParent, nestedKeysInput.slice(1), value);
    }
    else if (isLengthAtLeast(nestedKeysInput, 1)) {
        inputObject[nestedKeysInput[0]] = value;
    }
}
export function getValueFromNestedKeys(originalObject, nestedKeys) {
    /**
     * Lots of as any casts in here because these types are, under the hood, pretty complex. Since
     * the inputs and outputs of this function are well typed, these internal as any casts do not
     * affect the external API of this function.
     */
    const nestedKeysInput = nestedKeys;
    const inputObject = originalObject;
    if (isRunTimeType(inputObject, 'array')) {
        return inputObject.map((entry) => getValueFromNestedKeys(entry, nestedKeys));
    }
    const keyToAccess = nestedKeysInput[0];
    if (!typedHasProperty(inputObject, keyToAccess)) {
        return undefined;
    }
    const currentValue = inputObject[keyToAccess];
    if (nestedKeysInput.length > 1) {
        return getValueFromNestedKeys(currentValue, nestedKeysInput.slice(1));
    }
    else {
        return currentValue;
    }
}
