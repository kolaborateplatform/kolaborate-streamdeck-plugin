"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fillInOptions = exports.getPrettierOptionType = exports.defaultMultilineArrayOptions = exports.optionPropertyValidators = exports.optionHelp = exports.resetComment = exports.untilSetWrapThresholdCommentRegExp = exports.setWrapThresholdComment = exports.untilNextWrapThresholdCommentRegExp = exports.nextWrapThresholdComment = exports.untilSetLinePatternCommentRegExp = exports.setLinePatternComment = exports.untilNextLinePatternCommentRegExp = exports.nextLinePatternComment = exports.envDebugKey = void 0;
const common_1 = require("@augment-vir/common");
exports.envDebugKey = 'NEW_LINE_DEBUG';
exports.nextLinePatternComment = 'prettier-multiline-arrays-next-line-pattern:';
// all the text up until the comment trigger
exports.untilNextLinePatternCommentRegExp = new RegExp(`.*${exports.nextLinePatternComment}`);
exports.setLinePatternComment = 'prettier-multiline-arrays-set-line-pattern:';
// all the text up until the comment trigger
exports.untilSetLinePatternCommentRegExp = new RegExp(`.*${exports.setLinePatternComment}`);
exports.nextWrapThresholdComment = 'prettier-multiline-arrays-next-threshold:';
// all the text up until the comment trigger
exports.untilNextWrapThresholdCommentRegExp = new RegExp(`.*${exports.nextWrapThresholdComment}`);
exports.setWrapThresholdComment = 'prettier-multiline-arrays-set-threshold:';
// all the text up until the comment trigger
exports.untilSetWrapThresholdCommentRegExp = new RegExp(`.*${exports.setWrapThresholdComment}`);
exports.resetComment = 'prettier-multiline-arrays-reset';
exports.optionHelp = {
    multilineArraysWrapThreshold: `A number indicating that all arrays should wrap when they have MORE than the specified number. Defaults to -1, indicating that no special wrapping enforcement will take place.\nExample: multilineArraysWrapThreshold: 3\nCan be overridden with a comment starting with ${exports.nextWrapThresholdComment}.\nComment example: // ${exports.nextWrapThresholdComment} 5`,
    multilineArraysLinePattern: `A string with a space separated list of numbers indicating how many elements should be on each line. The pattern repeats if an array is longer than the pattern. Defaults to an empty string. Any invalid numbers causes the whole pattern to revert to the default. This overrides the wrap threshold option.\nExample: elementsPerLinePattern: "3 2 1"\nCan be overridden with a comment starting with ${exports.nextLinePatternComment}.\nComment example: // ${exports.nextLinePatternComment} 3 2 1\nThis option overrides Prettier's default wrapping; multiple elements on one line will not be wrapped even if they don't fit within the column count.`,
    multilineFunctionArguments: 'Applies all array wrapping logic to function argument lists as well. Experimental: does not work at all right now.',
};
exports.optionPropertyValidators = {
    multilineArraysWrapThreshold(input) {
        return typeof input === 'number' && !isNaN(input);
    },
    multilineArraysLinePattern(input) {
        if (typeof input !== 'string') {
            return false;
        }
        const splitNumbers = input.split(' ');
        return splitNumbers.every((splitNumber) => {
            const numericSplit = Number(splitNumber);
            return !isNaN(numericSplit);
        });
    },
    multilineFunctionArguments(input) {
        return typeof input === 'boolean';
    },
};
exports.defaultMultilineArrayOptions = {
    multilineArraysWrapThreshold: -1,
    multilineArraysLinePattern: '',
    multilineFunctionArguments: false,
};
const optionTypeToPrettierOptionTypeMapping = {
    number: 'int',
    boolean: 'boolean',
    string: 'string',
};
function getPrettierOptionType(input) {
    const mappedType = optionTypeToPrettierOptionTypeMapping[typeof input];
    if (mappedType) {
        return mappedType;
    }
    else {
        throw new Error(`Unmapped option type: '${typeof input}'`);
    }
}
exports.getPrettierOptionType = getPrettierOptionType;
function fillInOptions(input) {
    if (!input || typeof input !== 'object') {
        return exports.defaultMultilineArrayOptions;
    }
    const newOptions = {
        ...input,
    };
    (0, common_1.getObjectTypedKeys)(exports.defaultMultilineArrayOptions).forEach((optionsKey) => {
        const inputValue = input[optionsKey];
        const defaultValue = exports.defaultMultilineArrayOptions[optionsKey];
        if (exports.optionPropertyValidators[optionsKey](inputValue)) {
            newOptions[optionsKey] = inputValue;
        }
        else {
            newOptions[optionsKey] =
                defaultValue;
        }
    });
    return newOptions;
}
exports.fillInOptions = fillInOptions;
