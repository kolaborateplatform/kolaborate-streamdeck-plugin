"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitUntilTruthy = exports.defaultWaitUntilDefinedOptions = exports.waitValue = exports.wait = void 0;
const error_1 = require("../error");
const deferred_promise_1 = require("./deferred-promise");
function wait(delayMs) {
    const deferredPromiseWrapper = (0, deferred_promise_1.createDeferredPromiseWrapper)();
    if (delayMs !== Infinity) {
        setTimeout(() => {
            deferredPromiseWrapper.resolve();
        }, delayMs <= 0 ? 0 : delayMs);
    }
    return deferredPromiseWrapper.promise;
}
exports.wait = wait;
async function waitValue(delayMs, returnValue) {
    return wait(delayMs).then(() => returnValue);
}
exports.waitValue = waitValue;
exports.defaultWaitUntilDefinedOptions = {
    interval: {
        milliseconds: 100,
    },
    timeout: {
        milliseconds: 10000,
    },
};
/**
 * Runs the predicate until it returns a truthy value, then returns that value. Use the options
 * input to modify the timeout and interval durations. Automatically catches errors and handles
 * async predicates.
 */
async function waitUntilTruthy(predicate, failureMessage, optionsInput = {}) {
    const options = {
        ...exports.defaultWaitUntilDefinedOptions,
        ...optionsInput,
    };
    let lastValue = undefined;
    let lastError;
    async function checkCondition() {
        try {
            lastValue = await predicate();
        }
        catch (error) {
            lastValue = undefined;
            lastError = error;
        }
    }
    const startTime = Date.now();
    while (!lastValue) {
        await checkCondition();
        await wait(options.interval.milliseconds);
        if (Date.now() - startTime >= options.timeout.milliseconds) {
            const message = failureMessage ? `${failureMessage}: ` : '';
            const preMessage = `${message}Timeout of "${options.timeout.milliseconds}" exceeded waiting for value to be defined`;
            if (lastError) {
                throw (0, error_1.ensureErrorAndPrependMessage)(lastError, preMessage);
            }
            else {
                throw new Error(preMessage);
            }
        }
    }
    return lastValue;
}
exports.waitUntilTruthy = waitUntilTruthy;
