"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getValueFromNestedKeys = exports.setValueWithNestedKeys = void 0;
const run_time_assertions_1 = require("run-time-assertions");
const object_1 = require("./object");
const typed_has_property_1 = require("./typed-has-property");
function setValueWithNestedKeys(originalObject, nestedKeys, value) {
    /**
     * Lots of as any casts in here because these types are, under the hood, pretty complex. Since
     * the inputs and outputs of this function are well typed, these internal as any casts do not
     * affect the external API of this function.
     */
    const nestedKeysInput = nestedKeys;
    const inputObject = originalObject;
    if ((0, run_time_assertions_1.isRunTimeType)(inputObject, 'array')) {
        inputObject.forEach((entry) => {
            if ((0, object_1.isObject)(entry)) {
                setValueWithNestedKeys(entry, nestedKeysInput, value);
            }
        });
        return;
    }
    const nextKey = nestedKeysInput[0];
    if (!(nextKey in inputObject)) {
        inputObject[nextKey] = {};
    }
    else if (!(0, object_1.isObject)(inputObject[nextKey])) {
        throw new Error(`Cannot set value at key '${String(nextKey)}' as its not an object.`);
    }
    const nextParent = inputObject[nextKey];
    if (nestedKeysInput.length > 2) {
        setValueWithNestedKeys(nextParent, nestedKeysInput.slice(1), value);
    }
    else {
        nextParent[nestedKeysInput[1]] = value;
    }
}
exports.setValueWithNestedKeys = setValueWithNestedKeys;
function getValueFromNestedKeys(originalObject, nestedKeys) {
    /**
     * Lots of as any casts in here because these types are, under the hood, pretty complex. Since
     * the inputs and outputs of this function are well typed, these internal as any casts do not
     * affect the external API of this function.
     */
    const nestedKeysInput = nestedKeys;
    const inputObject = originalObject;
    if ((0, run_time_assertions_1.isRunTimeType)(inputObject, 'array')) {
        return inputObject.map((entry) => getValueFromNestedKeys(entry, nestedKeys));
    }
    const keyToAccess = nestedKeysInput[0];
    if (!(0, typed_has_property_1.typedHasProperty)(inputObject, keyToAccess)) {
        return undefined;
    }
    const currentValue = inputObject[keyToAccess];
    if (nestedKeysInput.length > 1) {
        return getValueFromNestedKeys(currentValue, nestedKeysInput.slice(1));
    }
    else {
        return currentValue;
    }
}
exports.getValueFromNestedKeys = getValueFromNestedKeys;
