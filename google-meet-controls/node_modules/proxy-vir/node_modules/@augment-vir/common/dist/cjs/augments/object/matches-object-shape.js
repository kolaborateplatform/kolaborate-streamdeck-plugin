"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertMatchesObjectShape = exports.matchesObjectShape = void 0;
const boolean_1 = require("../boolean");
const error_1 = require("../error");
const object_1 = require("./object");
const object_entries_1 = require("./object-entries");
const typed_has_property_1 = require("./typed-has-property");
/**
 * Checks that the first input, testThisOne, matches the object shape of the second input,
 * compareToThisOne. Does not compare exact values of properties, only types.
 *
 * To allow the test input, the first input, to have additional keys that the compare input, the
 * second input, does not have, pass in a third argument set to true.
 *
 * This function REQUIRES a generic to be assigned to it: it cannot infer it from the inputs.
 *
 * The compare input, the second input, is required to have at least one entry in every array value
 * that exists. If more array values are present, they will be considered other possible types for
 * entries in that array.
 */
function matchesObjectShape(testThisOne, compareToThisOne, allowExtraProps = false, shouldLogWhy = false) {
    try {
        assertMatchesObjectShape(testThisOne, compareToThisOne, allowExtraProps);
        return true;
    }
    catch (error) {
        if (shouldLogWhy) {
            console.error(error);
        }
        return false;
    }
}
exports.matchesObjectShape = matchesObjectShape;
/**
 * Asserts that the first input, testThisOne, matches the object shape of the second input,
 * compareToThisOne. Does not compare exact values of properties, only types.
 *
 * To allow the test input, the first input, to have additional keys that the compare input, the
 * second input, does not have, pass in a third argument set to true.
 *
 * This function REQUIRES a generic to be assigned to it: it cannot infer it from the inputs.
 *
 * The compare input, the second input, is required to have at least one entry in every array value
 * that exists. If more array values are present, they will be considered other possible types for
 * entries in that array.
 */
function assertMatchesObjectShape(testThisOne, compareToThisOne, allowExtraProps = false, noCheckInnerValueOfTheseKeys = {}) {
    const testKeys = (0, object_entries_1.getObjectTypedKeys)(testThisOne);
    const matchKeys = new Set((0, object_entries_1.getObjectTypedKeys)(compareToThisOne));
    if (!allowExtraProps) {
        const extraKeys = testKeys.filter((testKey) => !matchKeys.has(testKey));
        if (extraKeys.length) {
            throw new Error(`Test object has extra keys: ${extraKeys.join(', ')}`);
        }
    }
    matchKeys.forEach((key) => {
        if (!(0, typed_has_property_1.typedHasProperty)(testThisOne, key)) {
            throw new Error(`test object does not have key "${String(key)}" from expected shape.`);
        }
        function throwKeyError(reason) {
            throw new Error(`test object value at key "${String(key)}" did not match expected shape: ${reason}`);
        }
        const testValue = testThisOne[key];
        const shouldMatch = compareToThisOne[key];
        if (!noCheckInnerValueOfTheseKeys[key]) {
            compareInnerValue(testValue, shouldMatch, throwKeyError, allowExtraProps, noCheckInnerValueOfTheseKeys[key] ?? {});
        }
    });
}
exports.assertMatchesObjectShape = assertMatchesObjectShape;
function compareInnerValue(testValue, matchValue, throwKeyError, allowExtraProps, noCheckInnerValueOfTheseKeys) {
    const testType = typeof testValue;
    const shouldMatchType = typeof matchValue;
    if (testType !== shouldMatchType) {
        throwKeyError(`type "${testType}" did not match expected type "${shouldMatchType}"`);
    }
    try {
        if ((0, typed_has_property_1.typedHasProperty)(matchValue, 'constructor')) {
            if (!(0, typed_has_property_1.typedHasProperty)(testValue, 'constructor') ||
                testValue.constructor !== matchValue.constructor) {
                throwKeyError(`constructor "${testValue?.constructor?.name}" did not match expected constructor "${matchValue.constructor}"`);
            }
        }
    }
    catch (error) {
        // ignore errors from trying to find the constructor
        if (error instanceof throwKeyError) {
            throw error;
        }
    }
    if (Array.isArray(matchValue)) {
        if (!Array.isArray(testValue)) {
            throwKeyError(`expected an array`);
        }
        testValue.forEach((testValueEntry, index) => {
            const errors = matchValue
                .map((matchValue) => {
                try {
                    compareInnerValue(testValueEntry, matchValue, throwKeyError, allowExtraProps, noCheckInnerValueOfTheseKeys);
                    return undefined;
                }
                catch (error) {
                    return new Error(`entry at index "${index}" did not match expected shape: ${(0, error_1.extractErrorMessage)(error)}`);
                }
            })
                .filter(boolean_1.isTruthy);
            if (errors.length === matchValue.length) {
                throw new Error(`entry at index "${index}" did not match any of the possible types from "${matchValue.join(', ')}"`);
            }
        });
    }
    else if ((0, object_1.isObject)(matchValue)) {
        assertMatchesObjectShape(testValue, matchValue, allowExtraProps, noCheckInnerValueOfTheseKeys);
    }
}
