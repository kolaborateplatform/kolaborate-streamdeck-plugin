"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeAndReturnError = exports.wrapInTry = exports.ensureErrorAndPrependMessage = exports.ensureError = exports.extractErrorMessage = exports.combineErrorMessages = exports.combineErrors = void 0;
const boolean_1 = require("./boolean");
const typed_has_property_1 = require("./object/typed-has-property");
const promise_1 = require("./promise/promise");
function combineErrors(errors) {
    if (!errors || errors.length === 0) {
        return undefined;
    }
    const firstError = errors[0];
    if (errors.length === 1 && firstError) {
        return firstError;
    }
    return new Error(errors.map((error) => extractErrorMessage(error).trim()).join('\n'));
}
exports.combineErrors = combineErrors;
function combineErrorMessages(errors) {
    if (!errors) {
        return '';
    }
    return errors.map(extractErrorMessage).filter(boolean_1.isTruthy).join('\n');
}
exports.combineErrorMessages = combineErrorMessages;
function extractErrorMessage(maybeError) {
    if (!maybeError) {
        return '';
    }
    if (maybeError instanceof Error) {
        return maybeError.message;
    }
    else if ((0, typed_has_property_1.typedHasProperty)(maybeError, 'message')) {
        return String(maybeError.message);
    }
    else {
        return String(maybeError);
    }
}
exports.extractErrorMessage = extractErrorMessage;
function ensureError(maybeError) {
    if (maybeError instanceof Error) {
        return maybeError;
    }
    else {
        return new Error(extractErrorMessage(maybeError));
    }
}
exports.ensureError = ensureError;
function ensureErrorAndPrependMessage(maybeError, prependMessage) {
    const error = ensureError(maybeError);
    error.message = `${prependMessage}: ${error.message}`;
    return error;
}
exports.ensureErrorAndPrependMessage = ensureErrorAndPrependMessage;
function wrapInTry(inputs) {
    try {
        const returnValue = inputs.callback();
        if (returnValue instanceof Promise) {
            return returnValue.catch((error) => {
                if (inputs.catchCallback) {
                    return inputs.catchCallback(error);
                }
                else {
                    return inputs.fallbackValue;
                }
            });
        }
        else {
            return returnValue;
        }
    }
    catch (error) {
        if (inputs.catchCallback) {
            return inputs.catchCallback(error);
        }
        else {
            return inputs.fallbackValue;
        }
    }
}
exports.wrapInTry = wrapInTry;
function executeAndReturnError(callback) {
    let caughtError;
    try {
        const result = callback();
        if ((0, promise_1.isPromiseLike)(result)) {
            return new Promise(async (resolve) => {
                try {
                    const output = await result;
                    return resolve(output);
                }
                catch (error) {
                    caughtError = ensureError(error);
                }
                return resolve(caughtError);
            });
        }
        else {
            return result;
        }
    }
    catch (error) {
        caughtError = ensureError(error);
    }
    return caughtError;
}
exports.executeAndReturnError = executeAndReturnError;
