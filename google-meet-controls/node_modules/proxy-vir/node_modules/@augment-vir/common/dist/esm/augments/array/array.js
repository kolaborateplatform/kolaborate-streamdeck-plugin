import { typedObjectFromEntries } from '../object/object-entries';
export function filterOutIndexes(array, indexes) {
    return array.filter((_, index) => !indexes.includes(index));
}
export function flatten2dArray(array2d) {
    const flattened = array2d.reduce((accum, row) => accum.concat(row), []);
    return flattened;
}
export function trimArrayStrings(input) {
    return input.map((line) => line.trim()).filter((line) => line !== '');
}
export function typedArrayIncludes(array, input) {
    return array.includes(input);
}
/** Preserves tuple types. */
export function typedMap(arrayToMap, mapCallback) {
    return arrayToMap.map(mapCallback);
}
export function repeatArray(repeatCount, array) {
    return Array.from({ length: repeatCount }, () => [...array]).flat();
}
/**
 * Polyfill for `Object.groupBy`:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/groupBy
 */
export function groupArrayBy(inputArray, callback) {
    return inputArray.reduce((accum, entry, index, originalArray) => {
        const key = callback(entry, index, originalArray);
        if (!(key in accum)) {
            accum[key] = [];
        }
        accum[key].push(entry);
        return accum;
    }, {});
}
/**
 * Like `groupArrayBy` but maps array entries to a single key. Meaning, the resulting object does
 * not have an array of elements (unless the original array itself contains arrays).
 */
export function arrayToObject(inputArray, callback) {
    return typedObjectFromEntries(inputArray.map((entry, index, originalArray) => {
        const key = callback(entry, index, originalArray);
        return [
            key,
            entry,
        ];
    }));
}
export function filterMap(inputArray, mapCallback, filterCallback) {
    return inputArray.reduce((accum, entry, index, originalArray) => {
        const mapOutput = mapCallback(entry, index, originalArray);
        const filterOutput = filterCallback(mapOutput, entry, index, originalArray);
        if (filterOutput) {
            accum.push(mapOutput);
        }
        return accum;
    }, []);
}
