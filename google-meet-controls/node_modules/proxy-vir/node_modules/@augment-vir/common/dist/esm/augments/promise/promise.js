import { typedHasProperty } from '../object/typed-has-property';
export function isPromiseLike(input) {
    if (typedHasProperty(input, 'then') && typeof input.then === 'function') {
        return true;
    }
    else {
        return false;
    }
}
export class PromiseTimeoutError extends Error {
    constructor(durationMs, message = `Promised timed out after ${durationMs} ms.`) {
        super(message);
        Object.defineProperty(this, "durationMs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: durationMs
        });
        Object.defineProperty(this, "message", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: message
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'PromiseTimeoutError'
        });
    }
}
export function wrapPromiseInTimeout(durationMs, originalPromise) {
    return new Promise(async (resolve, reject) => {
        const timeoutId = durationMs === Infinity
            ? undefined
            : setTimeout(() => {
                reject(new PromiseTimeoutError(durationMs));
            }, durationMs);
        try {
            const result = await originalPromise;
            resolve(result);
        }
        catch (error) {
            reject(error);
        }
        finally {
            clearTimeout(timeoutId);
        }
    });
}
/**
 * Call a function asynchronously without interrupting current synchronous execution, even if the
 * function was originally synchronous.
 */
export async function callAsynchronously(callback) {
    return await Promise.resolve().then(() => callback());
}
export async function executeWithRetries(retryCount, callback) {
    let currentRetry = 0;
    while (currentRetry < retryCount) {
        try {
            const result = await callback();
            return result;
        }
        catch (error) {
            currentRetry++;
        }
    }
    throw new Error('Retry max reached.');
}
