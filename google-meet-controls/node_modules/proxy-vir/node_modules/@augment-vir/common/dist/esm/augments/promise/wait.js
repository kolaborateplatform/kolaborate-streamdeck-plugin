import { ensureErrorAndPrependMessage } from '../error';
import { createDeferredPromiseWrapper } from './deferred-promise';
export function wait(delayMs) {
    const deferredPromiseWrapper = createDeferredPromiseWrapper();
    if (delayMs !== Infinity) {
        setTimeout(() => {
            deferredPromiseWrapper.resolve();
        }, delayMs <= 0 ? 0 : delayMs);
    }
    return deferredPromiseWrapper.promise;
}
export async function waitValue(delayMs, returnValue) {
    return wait(delayMs).then(() => returnValue);
}
export const defaultWaitUntilDefinedOptions = {
    interval: {
        milliseconds: 100,
    },
    timeout: {
        milliseconds: 10000,
    },
};
/**
 * Runs the predicate until it returns a truthy value, then returns that value. Use the options
 * input to modify the timeout and interval durations. Automatically catches errors and handles
 * async predicates.
 */
export async function waitUntilTruthy(predicate, failureMessage, optionsInput = {}) {
    const options = {
        ...defaultWaitUntilDefinedOptions,
        ...optionsInput,
    };
    let lastValue = undefined;
    let lastError;
    async function checkCondition() {
        try {
            lastValue = await predicate();
        }
        catch (error) {
            lastValue = undefined;
            lastError = error;
        }
    }
    const startTime = Date.now();
    while (!lastValue) {
        await checkCondition();
        await wait(options.interval.milliseconds);
        if (Date.now() - startTime >= options.timeout.milliseconds) {
            const message = failureMessage ? `${failureMessage}: ` : '';
            const preMessage = `${message}Timeout of "${options.timeout.milliseconds}" exceeded waiting for value to be defined`;
            if (lastError) {
                throw ensureErrorAndPrependMessage(lastError, preMessage);
            }
            else {
                throw new Error(preMessage);
            }
        }
    }
    return lastValue;
}
