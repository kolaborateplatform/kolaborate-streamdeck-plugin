import { removeCommasFromNumberString } from './common-string';
import { safeMatch } from './regexp';
export const NaNString = String(NaN);
export function addCommasToNumber(input) {
    if (typeof input === 'string' && isNaN(Number(input))) {
        return NaNString;
    }
    const numericValue = Number(input);
    const isNegative = numericValue < 0;
    const stringValue = String(Math.abs(numericValue));
    const [digits, decimalValues,] = stringValue.split('.');
    const decimalString = decimalValues ? `.${decimalValues}` : '';
    const separated = safeMatch(digits.split('').reverse().join(''), /.{1,3}/g)
        .reverse()
        .map((entry) => entry.split('').reverse().join(''));
    const valueWithCommas = separated.join(',');
    const negativeMarker = isNegative ? '-' : '';
    return [
        negativeMarker,
        valueWithCommas,
        decimalString,
    ].join('');
}
export function convertIntoNumber(input) {
    if (typeof input === 'number') {
        return input;
    }
    else if (typeof input === 'string') {
        return Number(removeCommasFromNumberString(input));
    }
    else {
        return Number(input);
    }
}
export function doesRequireScientificNotation(input) {
    return String(input).includes('e');
}
/**
 * Given a min and max, ensures that they are in correct order. Meaning, min is less than max. If
 * that is not the case, the returned value is the given min and max values swapped.
 */
export function ensureMinAndMax({ min, max }) {
    if (min > max) {
        return { min: max, max: min };
    }
    else {
        return { min, max };
    }
}
export function toEnsuredNumber(input) {
    const numeric = Number(input);
    if (isNaN(numeric)) {
        throw new Error(`Cannot convert given input to a number: ${input}`);
    }
    else {
        return numeric;
    }
}
/**
 * If the given value is outside the given min/max bounds, instead of clamping the number (as the
 * `clamp` function does), this function wraps the value around to the next bound.
 *
 * @example
 *     wrapNumber({min: 0, max: 100, value: 101}) == 0;
 */
export function wrapNumber({ max, min, value }) {
    if (value > max) {
        return min;
    }
    else if (value < min) {
        return max;
    }
    return value;
}
export function round(inputs) {
    const digitFactor = Math.pow(10, inputs.digits);
    const multiplied = inputs.number * digitFactor;
    return Number((Math.round(multiplied) / digitFactor).toFixed(inputs.digits));
}
/** Clamp's the given value to within the min and max bounds, inclusive. */
export function clamp({ value, min, max }) {
    return Math.min(Math.max(value, min), max);
}
