import { isTruthy } from '../boolean';
import { extractErrorMessage } from '../error';
import { isObject } from './object';
import { getObjectTypedKeys } from './object-entries';
import { typedHasProperty } from './typed-has-property';
/**
 * Checks that the first input, testThisOne, matches the object shape of the second input,
 * compareToThisOne. Does not compare exact values of properties, only types.
 *
 * To allow the test input, the first input, to have additional keys that the compare input, the
 * second input, does not have, pass in a third argument set to true.
 *
 * This function REQUIRES a generic to be assigned to it: it cannot infer it from the inputs.
 *
 * The compare input, the second input, is required to have at least one entry in every array value
 * that exists. If more array values are present, they will be considered other possible types for
 * entries in that array.
 */
export function matchesObjectShape(testThisOne, compareToThisOne, allowExtraProps = false, shouldLogWhy = false) {
    try {
        assertMatchesObjectShape(testThisOne, compareToThisOne, allowExtraProps);
        return true;
    }
    catch (error) {
        if (shouldLogWhy) {
            console.error(error);
        }
        return false;
    }
}
/**
 * Asserts that the first input, testThisOne, matches the object shape of the second input,
 * compareToThisOne. Does not compare exact values of properties, only types.
 *
 * To allow the test input, the first input, to have additional keys that the compare input, the
 * second input, does not have, pass in a third argument set to true.
 *
 * This function REQUIRES a generic to be assigned to it: it cannot infer it from the inputs.
 *
 * The compare input, the second input, is required to have at least one entry in every array value
 * that exists. If more array values are present, they will be considered other possible types for
 * entries in that array.
 */
export function assertMatchesObjectShape(testThisOne, compareToThisOne, allowExtraProps = false, noCheckInnerValueOfTheseKeys = {}) {
    const testKeys = getObjectTypedKeys(testThisOne);
    const matchKeys = new Set(getObjectTypedKeys(compareToThisOne));
    if (!allowExtraProps) {
        const extraKeys = testKeys.filter((testKey) => !matchKeys.has(testKey));
        if (extraKeys.length) {
            throw new Error(`Test object has extra keys: ${extraKeys.join(', ')}`);
        }
    }
    matchKeys.forEach((key) => {
        if (!typedHasProperty(testThisOne, key)) {
            throw new Error(`test object does not have key "${String(key)}" from expected shape.`);
        }
        function throwKeyError(reason) {
            throw new Error(`test object value at key "${String(key)}" did not match expected shape: ${reason}`);
        }
        const testValue = testThisOne[key];
        const shouldMatch = compareToThisOne[key];
        if (!noCheckInnerValueOfTheseKeys[key]) {
            compareInnerValue(testValue, shouldMatch, throwKeyError, allowExtraProps, noCheckInnerValueOfTheseKeys[key] ?? {});
        }
    });
}
function compareInnerValue(testValue, matchValue, throwKeyError, allowExtraProps, noCheckInnerValueOfTheseKeys) {
    const testType = typeof testValue;
    const shouldMatchType = typeof matchValue;
    if (testType !== shouldMatchType) {
        throwKeyError(`type "${testType}" did not match expected type "${shouldMatchType}"`);
    }
    try {
        if (typedHasProperty(matchValue, 'constructor')) {
            if (!typedHasProperty(testValue, 'constructor') ||
                testValue.constructor !== matchValue.constructor) {
                throwKeyError(`constructor "${testValue?.constructor?.name}" did not match expected constructor "${matchValue.constructor}"`);
            }
        }
    }
    catch (error) {
        // ignore errors from trying to find the constructor
        if (error instanceof throwKeyError) {
            throw error;
        }
    }
    if (Array.isArray(matchValue)) {
        if (!Array.isArray(testValue)) {
            throwKeyError(`expected an array`);
        }
        testValue.forEach((testValueEntry, index) => {
            const errors = matchValue
                .map((matchValue) => {
                try {
                    compareInnerValue(testValueEntry, matchValue, throwKeyError, allowExtraProps, noCheckInnerValueOfTheseKeys);
                    return undefined;
                }
                catch (error) {
                    return new Error(`entry at index "${index}" did not match expected shape: ${extractErrorMessage(error)}`);
                }
            })
                .filter(isTruthy);
            if (errors.length === matchValue.length) {
                throw new Error(`entry at index "${index}" did not match any of the possible types from "${matchValue.join(', ')}"`);
            }
        });
    }
    else if (isObject(matchValue)) {
        assertMatchesObjectShape(testValue, matchValue, allowExtraProps, noCheckInnerValueOfTheseKeys);
    }
}
