import { isRunTimeType } from 'run-time-assertions';
import { isObject } from './object';
import { typedHasProperty } from './typed-has-property';
export function setValueWithNestedKeys(originalObject, nestedKeys, value) {
    /**
     * Lots of as any casts in here because these types are, under the hood, pretty complex. Since
     * the inputs and outputs of this function are well typed, these internal as any casts do not
     * affect the external API of this function.
     */
    const nestedKeysInput = nestedKeys;
    const inputObject = originalObject;
    if (isRunTimeType(inputObject, 'array')) {
        inputObject.forEach((entry) => {
            if (isObject(entry)) {
                setValueWithNestedKeys(entry, nestedKeysInput, value);
            }
        });
        return;
    }
    const nextKey = nestedKeysInput[0];
    if (!(nextKey in inputObject)) {
        inputObject[nextKey] = {};
    }
    else if (!isObject(inputObject[nextKey])) {
        throw new Error(`Cannot set value at key '${String(nextKey)}' as its not an object.`);
    }
    const nextParent = inputObject[nextKey];
    if (nestedKeysInput.length > 2) {
        setValueWithNestedKeys(nextParent, nestedKeysInput.slice(1), value);
    }
    else {
        nextParent[nestedKeysInput[1]] = value;
    }
}
export function getValueFromNestedKeys(originalObject, nestedKeys) {
    /**
     * Lots of as any casts in here because these types are, under the hood, pretty complex. Since
     * the inputs and outputs of this function are well typed, these internal as any casts do not
     * affect the external API of this function.
     */
    const nestedKeysInput = nestedKeys;
    const inputObject = originalObject;
    if (isRunTimeType(inputObject, 'array')) {
        return inputObject.map((entry) => getValueFromNestedKeys(entry, nestedKeys));
    }
    const keyToAccess = nestedKeysInput[0];
    if (!typedHasProperty(inputObject, keyToAccess)) {
        return undefined;
    }
    const currentValue = inputObject[keyToAccess];
    if (nestedKeysInput.length > 1) {
        return getValueFromNestedKeys(currentValue, nestedKeysInput.slice(1));
    }
    else {
        return currentValue;
    }
}
