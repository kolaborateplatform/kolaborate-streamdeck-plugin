import { PropertyValueType } from './object';
export type InnerMappedValues<EntireInputGeneric extends object, MappedValueGeneric> = {
    [MappedProp in keyof EntireInputGeneric]: MappedValueGeneric;
};
export type MappedValues<EntireInputGeneric extends object, MappedValueGeneric> = MappedValueGeneric extends PromiseLike<unknown> ? Promise<InnerMappedValues<EntireInputGeneric, Awaited<MappedValueGeneric>>> : InnerMappedValues<EntireInputGeneric, Awaited<MappedValueGeneric>>;
/**
 * Map an object's keys to new values synchronously. This is different from plain mapObjectValues in
 * that this will not wrap the return value in a promise if any of the new object values are
 * promises. This function also requires currying in order to get the types correct. This allows you
 * to explicitly state the return type.
 *
 * @example
 *     mapObjectValuesSync({objectToIterateOver: 'initial value'})(callback);
 */
export declare function mapObjectValuesSync<EntireInputGeneric extends object>(inputObject: EntireInputGeneric): <OutputObjectGeneric extends object>(mapCallback: (inputKey: keyof EntireInputGeneric, keyValue: Required<EntireInputGeneric>[typeof inputKey], fullObject: EntireInputGeneric) => never extends PropertyValueType<OutputObjectGeneric> ? any : PropertyValueType<OutputObjectGeneric>) => OutputObjectGeneric;
/**
 * Creates a new object with the same properties as the input object, but with values set to the
 * result of mapCallback for each property.
 */
export declare function mapObjectValues<EntireInputGeneric extends object, MappedValueGeneric>(inputObject: EntireInputGeneric, mapCallback: (inputKey: keyof EntireInputGeneric, keyValue: Required<EntireInputGeneric>[typeof inputKey], fullObject: EntireInputGeneric) => MappedValueGeneric): MappedValues<EntireInputGeneric, MappedValueGeneric>;
