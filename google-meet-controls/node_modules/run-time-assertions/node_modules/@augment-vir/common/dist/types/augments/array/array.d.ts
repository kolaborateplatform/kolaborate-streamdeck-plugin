import { AtLeastTuple } from '../tuple';
import { ArrayElement } from '../type';
export declare function filterOutIndexes<T>(array: ReadonlyArray<T>, indexes: ReadonlyArray<number>): T[];
export declare function flatten2dArray<T>(array2d: ReadonlyArray<ReadonlyArray<T>>): T[];
export type AtLeastOneEntryArray<ArrayGeneric extends ReadonlyArray<any>> = AtLeastTuple<ArrayElement<ArrayGeneric>, 1>;
export declare function trimArrayStrings(input: ReadonlyArray<string>): string[];
export declare function typedArrayIncludes<T>(array: ReadonlyArray<T>, input: unknown): input is T;
type MapCallbackType<ArrayType extends ReadonlyArray<any>, OutputType> = (value: ArrayElement<ArrayType>, index: number, array: ArrayType) => OutputType;
/** Preserves tuple types. */
export declare function typedMap<InputArrayGeneric extends ReadonlyArray<any>, OutputType>(arrayToMap: InputArrayGeneric, mapCallback: MapCallbackType<InputArrayGeneric, OutputType>): {
    [Index in keyof InputArrayGeneric]: OutputType;
};
export declare function repeatArray<T>(repeatCount: number, array: T[]): T[];
/**
 * Polyfill for `Object.groupBy`:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/groupBy
 */
export declare function groupArrayBy<ElementType, NewKey extends PropertyKey>(inputArray: ReadonlyArray<ElementType>, callback: (entry: ElementType, index: number, originalArray: ReadonlyArray<ElementType>) => NewKey): Partial<Record<NewKey, ElementType[]>>;
/**
 * Like `groupArrayBy` but maps array entries to a single key. Meaning, the resulting object does
 * not have an array of elements (unless the original array itself contains arrays).
 */
export declare function arrayToObject<ElementType, NewKey extends PropertyKey>(inputArray: ReadonlyArray<ElementType>, callback: (entry: ElementType, index: number, originalArray: ReadonlyArray<ElementType>) => NewKey): Partial<Record<NewKey, ElementType>>;
export declare function filterMap<ElementType, MappedEntry, TypeGuarded extends MappedEntry>(inputArray: ReadonlyArray<ElementType>, mapCallback: (entry: ElementType, index: number, originalArray: ReadonlyArray<ElementType>) => MappedEntry, filterCallback: (mappedOutput: MappedEntry, originalEntry: ElementType, index: number, originalArray: ReadonlyArray<ElementType>) => mappedOutput is TypeGuarded): TypeGuarded[];
export declare function filterMap<ElementType, MappedEntry>(inputArray: ReadonlyArray<ElementType>, mapCallback: (entry: ElementType, index: number, originalArray: ReadonlyArray<ElementType>) => MappedEntry, filterCallback: (mappedOutput: MappedEntry, originalEntry: ElementType, index: number, originalArray: ReadonlyArray<ElementType>) => boolean): MappedEntry[];
export {};
