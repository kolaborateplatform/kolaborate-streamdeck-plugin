"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeDeep = mergeDeep;
const run_time_assertions_1 = require("run-time-assertions");
const tuple_1 = require("../tuple");
/**
 * Accepts multiple objects and merges their key-value pairs recursively. Any values set to
 * undefined will be removed.
 *
 * Note that order matters! Each input object will overwrite the properties of the previous objects.
 */
function mergeDeep(...inputs) {
    if (!(0, tuple_1.isLengthAtLeast)(inputs, 1)) {
        // nothing to merge if no inputs
        return {};
    }
    if (inputs.length === 1) {
        // nothing to merge if only one input
        return inputs[0];
    }
    let result = undefined;
    const mergeProps = {};
    inputs.forEach((individualInput) => {
        if (!(0, run_time_assertions_1.isRunTimeType)(individualInput, 'object')) {
            /** If not an object, we can't merge. So overwrite instead. */
            result = individualInput;
            return;
        }
        else if (!(0, run_time_assertions_1.isRunTimeType)(result, 'object')) {
            /** If result isn't an object then we need to make it into one. */
            result = { ...individualInput };
        }
        Object.entries(individualInput).forEach(([key, value,]) => {
            if (!mergeProps[key]) {
                mergeProps[key] = [];
            }
            mergeProps[key].push(value);
        });
    });
    if ((0, run_time_assertions_1.isRunTimeType)(result, 'object')) {
        Object.entries(mergeProps).forEach(([key, mergeValues,]) => {
            const newValue = mergeDeep(...mergeValues);
            if (newValue === undefined && key in result) {
                delete result[key];
            }
            else if (newValue !== undefined) {
                result[key] = newValue;
            }
        });
    }
    return result;
}
