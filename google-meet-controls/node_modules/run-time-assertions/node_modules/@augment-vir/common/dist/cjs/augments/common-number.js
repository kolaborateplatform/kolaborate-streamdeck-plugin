"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertIntoNumber = exports.NaNString = void 0;
exports.addCommasToNumber = addCommasToNumber;
exports.doesRequireScientificNotation = doesRequireScientificNotation;
exports.ensureMinAndMax = ensureMinAndMax;
exports.toNumber = toNumber;
exports.toEnsuredNumber = toEnsuredNumber;
exports.toMaybeNumber = toMaybeNumber;
exports.wrapNumber = wrapNumber;
exports.round = round;
exports.clamp = clamp;
const common_string_1 = require("./common-string");
const regexp_1 = require("./regexp");
exports.NaNString = String(NaN);
function addCommasToNumber(input) {
    if (typeof input === 'string' && isNaN(Number(input))) {
        return exports.NaNString;
    }
    const numericValue = Number(input);
    const isNegative = numericValue < 0;
    const stringValue = String(Math.abs(numericValue));
    const [digits, decimalValues,] = stringValue.split('.');
    const decimalString = decimalValues ? `.${decimalValues}` : '';
    const separated = (0, regexp_1.safeMatch)(digits.split('').reverse().join(''), /.{1,3}/g)
        .reverse()
        .map((entry) => entry.split('').reverse().join(''));
    const valueWithCommas = separated.join(',');
    const negativeMarker = isNegative ? '-' : '';
    return [
        negativeMarker,
        valueWithCommas,
        decimalString,
    ].join('');
}
function doesRequireScientificNotation(input) {
    return String(input).includes('e');
}
/**
 * Given a min and max, ensures that they are in correct order. Meaning, min is less than max. If
 * that is not the case, the returned value is the given min and max values swapped.
 */
function ensureMinAndMax({ min, max }) {
    if (min > max) {
        return { min: max, max: min };
    }
    else {
        return { min, max };
    }
}
/**
 * Tries to convert the input into a number. Handles strings with commas. Note: this might return
 * `NaN`.
 */
function toNumber(input) {
    if (typeof input === 'number') {
        return input;
    }
    else if (typeof input === 'string') {
        return Number((0, common_string_1.removeCommasFromNumberString)(input));
    }
    else {
        return Number(input);
    }
}
/** @deprecated Use {@link toNumber} instead. */
exports.convertIntoNumber = toNumber;
/** Tries to convert the input into a number and throws an error if `NaN` is created. */
function toEnsuredNumber(input) {
    const numeric = toMaybeNumber(input);
    if (numeric == undefined) {
        throw new Error(`Cannot convert to a number: ${input}`);
    }
    else {
        return numeric;
    }
}
/** Tries to convert the input into a number and returns `undefined` if `NaN` is created. */
function toMaybeNumber(input) {
    const numeric = toNumber(input);
    if (isNaN(numeric)) {
        return undefined;
    }
    else {
        return numeric;
    }
}
/**
 * If the given value is outside the given min/max bounds, instead of clamping the number (as the
 * `clamp` function does), this function wraps the value around to the next bound.
 *
 * @example
 *     wrapNumber({min: 0, max: 100, value: 101}) == 0;
 */
function wrapNumber({ max, min, value }) {
    if (value > max) {
        return min;
    }
    else if (value < min) {
        return max;
    }
    return value;
}
function round(inputs) {
    const digitFactor = Math.pow(10, inputs.digits);
    const multiplied = inputs.number * digitFactor;
    return Number((Math.round(multiplied) / digitFactor).toFixed(inputs.digits));
}
/** Clamp's the given value to within the min and max bounds, inclusive. */
function clamp({ value, min, max }) {
    return Math.min(Math.max(value, min), max);
}
