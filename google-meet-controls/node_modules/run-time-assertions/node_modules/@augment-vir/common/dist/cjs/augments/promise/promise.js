"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseTimeoutError = void 0;
exports.isPromiseLike = isPromiseLike;
exports.wrapPromiseInTimeout = wrapPromiseInTimeout;
exports.callAsynchronously = callAsynchronously;
exports.executeWithRetries = executeWithRetries;
const typed_has_property_1 = require("../object/typed-has-property");
function isPromiseLike(input) {
    if ((0, typed_has_property_1.typedHasProperty)(input, 'then') && typeof input.then === 'function') {
        return true;
    }
    else {
        return false;
    }
}
class PromiseTimeoutError extends Error {
    constructor(durationMs, message = `Promised timed out after ${durationMs} ms.`) {
        super(message);
        Object.defineProperty(this, "durationMs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: durationMs
        });
        Object.defineProperty(this, "message", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: message
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'PromiseTimeoutError'
        });
    }
}
exports.PromiseTimeoutError = PromiseTimeoutError;
function wrapPromiseInTimeout(durationMs, originalPromise) {
    return new Promise(async (resolve, reject) => {
        const timeoutId = durationMs === Infinity
            ? undefined
            : setTimeout(() => {
                reject(new PromiseTimeoutError(durationMs));
            }, durationMs);
        try {
            const result = await originalPromise;
            resolve(result);
        }
        catch (error) {
            reject(error);
        }
        finally {
            clearTimeout(timeoutId);
        }
    });
}
/**
 * Call a function asynchronously without interrupting current synchronous execution, even if the
 * function was originally synchronous.
 */
async function callAsynchronously(callback) {
    return await Promise.resolve().then(() => callback());
}
async function executeWithRetries(retryCount, callback) {
    let currentRetry = 0;
    while (currentRetry < retryCount) {
        try {
            const result = await callback();
            return result;
        }
        catch (error) {
            currentRetry++;
        }
    }
    throw new Error('Retry max reached.');
}
