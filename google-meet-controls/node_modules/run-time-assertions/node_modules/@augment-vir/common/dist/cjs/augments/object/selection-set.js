"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectFrom = selectFrom;
exports.selectCollapsedFrom = selectCollapsedFrom;
const run_time_assertions_1 = require("run-time-assertions");
const tuple_1 = require("../tuple");
const filter_object_1 = require("./filter-object");
const map_object_1 = require("./map-object");
const object_1 = require("./object");
function shouldPreserve(input) {
    return (0, run_time_assertions_1.isPrimitive)(input) || input instanceof RegExp || input instanceof Promise;
}
function selectFrom(originalObject, selectionSet) {
    if (Array.isArray(originalObject)) {
        return originalObject.map((originalEntry) => selectFrom(originalEntry, selectionSet));
    }
    const keysToRemove = [];
    return (0, filter_object_1.omitObjectKeys)((0, map_object_1.mapObjectValues)(originalObject, (key, value) => {
        const selection = selectionSet[key];
        if (selection === true) {
            return value;
        }
        else if (!selection) {
            keysToRemove.push(key);
            return undefined;
        }
        else if (shouldPreserve(value)) {
            return value;
        }
        else {
            return selectFrom(value, selection);
        }
    }), keysToRemove);
}
function selectCollapsedFrom(originalObject, selectionSet) {
    const selected = selectFrom(originalObject, selectionSet);
    return collapseObject(selected, selectionSet);
}
function collapseObject(input, selectionSet) {
    if (shouldPreserve(input)) {
        return input;
    }
    const keys = Object.keys(input);
    if (Array.isArray(input)) {
        return input.map((innerInput) => collapseObject(innerInput, selectionSet));
    }
    else if ((0, tuple_1.isLengthAtLeast)(keys, 2)) {
        return input;
    }
    else if ((0, tuple_1.isLengthAtLeast)(keys, 1) && (0, object_1.isObject)(selectionSet)) {
        return collapseObject(input[keys[0]], selectionSet[keys[0]]);
    }
    else {
        return input;
    }
}
