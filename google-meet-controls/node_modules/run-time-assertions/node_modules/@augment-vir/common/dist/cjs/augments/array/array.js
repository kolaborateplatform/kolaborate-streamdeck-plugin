"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterOutIndexes = filterOutIndexes;
exports.flatten2dArray = flatten2dArray;
exports.trimArrayStrings = trimArrayStrings;
exports.typedArrayIncludes = typedArrayIncludes;
exports.typedMap = typedMap;
exports.repeatArray = repeatArray;
exports.groupArrayBy = groupArrayBy;
exports.arrayToObject = arrayToObject;
exports.filterMap = filterMap;
const get_or_set_1 = require("../object/get-or-set");
const object_entries_1 = require("../object/object-entries");
function filterOutIndexes(array, indexes) {
    return array.filter((_, index) => !indexes.includes(index));
}
function flatten2dArray(array2d) {
    const flattened = array2d.reduce((accum, row) => accum.concat(row), []);
    return flattened;
}
function trimArrayStrings(input) {
    return input.map((line) => line.trim()).filter((line) => line !== '');
}
function typedArrayIncludes(array, input) {
    return array.includes(input);
}
/** Preserves tuple types. */
function typedMap(arrayToMap, mapCallback) {
    return arrayToMap.map(mapCallback);
}
function repeatArray(repeatCount, array) {
    return Array.from({ length: repeatCount }, () => [...array]).flat();
}
/**
 * Polyfill for `Object.groupBy`:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/groupBy
 */
function groupArrayBy(inputArray, callback) {
    return inputArray.reduce((accum, entry, index, originalArray) => {
        const key = callback(entry, index, originalArray);
        const entryArray = (0, get_or_set_1.getOrSet)(accum, key, () => []);
        entryArray.push(entry);
        return accum;
    }, {});
}
/**
 * Like `groupArrayBy` but maps array entries to a single key. Meaning, the resulting object does
 * not have an array of elements (unless the original array itself contains arrays).
 */
function arrayToObject(inputArray, callback) {
    return (0, object_entries_1.typedObjectFromEntries)(inputArray.map((entry, index, originalArray) => {
        const key = callback(entry, index, originalArray);
        return [
            key,
            entry,
        ];
    }));
}
function filterMap(inputArray, mapCallback, filterCallback) {
    return inputArray.reduce((accum, entry, index, originalArray) => {
        const mapOutput = mapCallback(entry, index, originalArray);
        const filterOutput = filterCallback(mapOutput, entry, index, originalArray);
        if (filterOutput) {
            accum.push(mapOutput);
        }
        return accum;
    }, []);
}
