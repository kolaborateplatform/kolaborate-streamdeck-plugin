"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.awaitedForEach = awaitedForEach;
exports.awaitedBlockingMap = awaitedBlockingMap;
exports.awaitedFilter = awaitedFilter;
/**
 * Acts like calling Array.prototype.forEach in that all elements are executed upon in order, and
 * each execution is blocking. Meaning, the callback won't be called on element 2 until the callback
 * has finished its call on element 1.
 */
async function awaitedForEach(input, callback) {
    await awaitedBlockingMap(input, callback);
}
async function awaitedBlockingMap(input, callback) {
    const mappedValues = await input.reduce(async (accumPromise, currentElement, index, wholeArray) => {
        const accum = await accumPromise;
        const mappedValue = await callback(currentElement, index, wholeArray);
        accum.push(mappedValue);
        return accum;
    }, Promise.resolve([]));
    return mappedValues;
}
async function awaitedFilter(arrayInput, filterCallback, options) {
    const callbackResults = options?.blocking
        ? await awaitedBlockingMap(arrayInput, filterCallback)
        : await Promise.all(arrayInput.map(filterCallback));
    return arrayInput.filter((originalValue, index) => !!callbackResults[index]);
}
