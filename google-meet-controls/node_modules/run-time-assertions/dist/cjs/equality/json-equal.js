"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonStringifyError = void 0;
exports.isJsonEqual = isJsonEqual;
exports.assertJsonEqual = assertJsonEqual;
exports.isLooseJsonEqual = isLooseJsonEqual;
exports.assertLooseJsonEqual = assertLooseJsonEqual;
const common_1 = require("@augment-vir/common");
const assertion_error_1 = require("../assertion.error");
/**
 * An error that is thrown from isJsonEqual or assertJsonEqual if the inputs fail on
 * `JSON.stringify`.
 */
class JsonStringifyError extends Error {
    constructor(message) {
        super(`Failed to compare objects using JSON.stringify: ${message}`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'JsonStringifyError'
        });
    }
}
exports.JsonStringifyError = JsonStringifyError;
function baseAreJsonEqual(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
}
/**
 * Check if the inputs are equal via `JSON.stringify` (property order on objects does not matter).
 *
 * @throws `JsonStringifyError` if the inputs fail when passed to `JSON.stringify`.
 */
function isJsonEqual(a, b) {
    try {
        if (a === b || baseAreJsonEqual(a, b)) {
            return true;
        }
        if ((0, common_1.isObject)(a) && (0, common_1.isObject)(b)) {
            const aKeys = Object.keys(a).sort();
            const bKeys = Object.keys(b).sort();
            if (aKeys.length || bKeys.length) {
                const areKeysEqual = baseAreJsonEqual(aKeys, bKeys);
                if (!areKeysEqual) {
                    return false;
                }
                return (0, common_1.getObjectTypedKeys)(a).every((keyName) => {
                    return isJsonEqual(a[keyName], b[keyName]);
                });
            }
        }
        return baseAreJsonEqual(a, b);
    }
    catch (caught) {
        throw new JsonStringifyError((0, common_1.extractErrorMessage)(caught));
    }
}
/**
 * Asserts that the inputs are equal via `JSON.stringify` (property order on objects does not
 * matter).
 *
 * @throws `JsonStringifyError` if the inputs fail when passed to `JSON.stringify`.
 * @throws `AssertionError` if the assertion fails.
 */
function assertJsonEqual(a, b) {
    if (!isJsonEqual(a, b)) {
        throw new assertion_error_1.AssertionError('Inputs are not JSON equal.');
    }
}
/**
 * Checks for equality between inputs with JSON but ignores top-level properties that are not
 * serializable.
 *
 * @throws Nothing: always returns a boolean.
 */
function isLooseJsonEqual(a, b) {
    try {
        if ((0, common_1.isObject)(a) && (0, common_1.isObject)(b)) {
            const allKeys = new Set([
                ...(0, common_1.getObjectTypedKeys)(a),
                ...(0, common_1.getObjectTypedKeys)(b),
            ]);
            if (allKeys.size) {
                return Array.from(allKeys).every((key) => {
                    if (!(0, common_1.hasKey)(a, key) || !(0, common_1.hasKey)(b, key)) {
                        return false;
                    }
                    const aValue = a[key];
                    const bValue = b[key];
                    if (typeof aValue !== typeof bValue) {
                        return false;
                    }
                    return (0, common_1.wrapInTry)(() => isJsonEqual(aValue, bValue), { fallbackValue: true });
                });
            }
        }
        return (0, common_1.wrapInTry)(() => isJsonEqual(a, b), { fallbackValue: false });
    }
    catch (error) {
        return false;
    }
}
/**
 * Asserts that the inputs are equal via `JSON.stringify` (property order on objects does not
 * matter).
 *
 * @throws `AssertionError` if the assertion fails.
 */
function assertLooseJsonEqual(a, b) {
    if (!isLooseJsonEqual(a, b)) {
        throw new assertion_error_1.AssertionError('Inputs are not loosely JSON equal.');
    }
}
