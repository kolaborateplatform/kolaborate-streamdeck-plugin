"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertThrows = assertThrows;
const common_1 = require("@augment-vir/common");
const assertion_error_1 = require("./assertion.error");
const is_promise_1 = require("./object/is-promise");
const run_time_types_1 = require("./run-time-types");
/**
 * Asserts that the given callback or promise throws and that what it throws matches, if provided,
 * the provided constructor or message string.
 */
function assertThrows(
/** The callback or promise to check for throwing. */
callbackOrPromise, 
/** Optional matching options. */
matching, 
/** Message to include in the error if the provided callback or promise does not throw. */
failureMessage) {
    let caughtError = undefined;
    const errorSuffix = failureMessage ? `\n\n${failureMessage}` : '';
    function runAssertion() {
        if (!caughtError) {
            throw new assertion_error_1.AssertionError(`No error was thrown${errorSuffix}`);
        }
        if (matching?.matchConstructor && !(caughtError instanceof matching.matchConstructor)) {
            const constructorName = caughtError.constructor.name;
            throw new assertion_error_1.AssertionError(`Error constructor '${constructorName}' did not match expected constructor '${matching.matchConstructor.name}'${errorSuffix}`);
        }
        if (matching?.matchMessage) {
            const message = (0, common_1.extractErrorMessage)(caughtError);
            if ((0, run_time_types_1.isRunTimeType)(matching.matchMessage, 'string')) {
                if (!message.includes(matching.matchMessage)) {
                    throw new assertion_error_1.AssertionError(`Error message\n\n'${message}'\n\ndid not contain\n\n'${matching.matchMessage}'${errorSuffix}`);
                }
            }
            else if (!message.match(matching.matchMessage)) {
                throw new assertion_error_1.AssertionError(`Error message\n\n'${message}'\n\ndid not match RegExp\n\n'${matching.matchMessage}'${errorSuffix}`);
            }
        }
    }
    try {
        const result = callbackOrPromise instanceof Promise ? callbackOrPromise : callbackOrPromise();
        if ((0, is_promise_1.isPromiseLike)(result)) {
            return new Promise(async (resolve, reject) => {
                try {
                    await result;
                }
                catch (error) {
                    caughtError = error;
                }
                try {
                    runAssertion();
                    resolve();
                }
                catch (error) {
                    reject(error);
                }
            });
        }
    }
    catch (error) {
        caughtError = error;
    }
    runAssertion();
}
