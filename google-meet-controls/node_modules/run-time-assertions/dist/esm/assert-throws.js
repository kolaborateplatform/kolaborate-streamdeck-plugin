import { extractErrorMessage } from '@augment-vir/common';
import { AssertionError } from './assertion.error';
import { isPromiseLike } from './object/is-promise';
import { isRunTimeType } from './run-time-types';
/**
 * Asserts that the given callback or promise throws and that what it throws matches, if provided,
 * the provided constructor or message string.
 */
export function assertThrows(
/** The callback or promise to check for throwing. */
callbackOrPromise, 
/** Optional matching options. */
matching, 
/** Message to include in the error if the provided callback or promise does not throw. */
failureMessage) {
    let caughtError = undefined;
    const errorSuffix = failureMessage ? `\n\n${failureMessage}` : '';
    function runAssertion() {
        if (!caughtError) {
            throw new AssertionError(`No error was thrown${errorSuffix}`);
        }
        if (matching?.matchConstructor && !(caughtError instanceof matching.matchConstructor)) {
            const constructorName = caughtError.constructor.name;
            throw new AssertionError(`Error constructor '${constructorName}' did not match expected constructor '${matching.matchConstructor.name}'${errorSuffix}`);
        }
        if (matching?.matchMessage) {
            const message = extractErrorMessage(caughtError);
            if (isRunTimeType(matching.matchMessage, 'string')) {
                if (!message.includes(matching.matchMessage)) {
                    throw new AssertionError(`Error message\n\n'${message}'\n\ndid not contain\n\n'${matching.matchMessage}'${errorSuffix}`);
                }
            }
            else if (!message.match(matching.matchMessage)) {
                throw new AssertionError(`Error message\n\n'${message}'\n\ndid not match RegExp\n\n'${matching.matchMessage}'${errorSuffix}`);
            }
        }
    }
    try {
        const result = callbackOrPromise instanceof Promise ? callbackOrPromise : callbackOrPromise();
        if (isPromiseLike(result)) {
            return new Promise(async (resolve, reject) => {
                try {
                    await result;
                }
                catch (error) {
                    caughtError = error;
                }
                try {
                    runAssertion();
                    resolve();
                }
                catch (error) {
                    reject(error);
                }
            });
        }
    }
    catch (error) {
        caughtError = error;
    }
    runAssertion();
}
