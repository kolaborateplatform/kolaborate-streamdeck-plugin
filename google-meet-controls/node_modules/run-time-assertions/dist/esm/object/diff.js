import { getObjectTypedKeys } from '@augment-vir/common';
import { isInstanceOf } from '../assertions';
import { isRunTimeType } from '../run-time-types';
/**
 * Extract all nested object keys and values that are different between the two given objects.
 *
 * @returns An empty tuple if the values are equal.
 */
export function diffObjects(object0, object1) {
    const allObjectKeys = Array.from(new Set([
        ...getObjectTypedKeys(object0),
        ...getObjectTypedKeys(object1),
    ]));
    const diffOutput = allObjectKeys.reduce((accum, objectKey) => {
        const value0 = object0[objectKey];
        const value1 = object1[objectKey];
        const diffOutput = diffValues(value0, value1);
        if (!diffOutput.length) {
            return accum;
        }
        if (!(objectKey in object0)) {
            accum[1][objectKey] = diffOutput[1];
        }
        else if (!(objectKey in object1)) {
            accum[0][objectKey] = diffOutput[0];
        }
        else {
            accum[0][objectKey] = diffOutput[0];
            accum[1][objectKey] = diffOutput[1];
        }
        return accum;
    }, [
        {},
        {},
    ]);
    if (!Object.keys(diffOutput[0]).length && !Object.keys(diffOutput[1]).length) {
        return [];
    }
    else {
        return diffOutput;
    }
}
/**
 * Extract all entries in the given arrays that are not equal.
 *
 * @returns An empty tuple if the values are equal.
 */
export function diffArrays(array0, array1) {
    const allArrayIndexes = Array.from(new Set([
        ...Object.keys(array0),
        ...Object.keys(array1),
    ].map((index) => Number(index)))).sort();
    const diffArrays = allArrayIndexes.reduce((accum, arrayIndex) => {
        const value0 = array0[arrayIndex];
        const value1 = array1[arrayIndex];
        const diffOutput = diffValues(value0, value1);
        if (diffOutput.length) {
            if (arrayIndex in array0) {
                accum[0].push(diffOutput[0]);
            }
            if (arrayIndex in array1) {
                accum[1].push(diffOutput[1]);
            }
        }
        return accum;
    }, [
        [],
        [],
    ]);
    if (!diffArrays[0].length && !diffArrays[1].length) {
        return [];
    }
    else {
        return diffArrays;
    }
}
/**
 * Simple diff check that is useful simply to return the same format as the other diff functions.
 *
 * @returns An empty tuple if the values are equal.
 */
export function diffBasic(value0, value1, 
/** A custom equality checker. Defaults to a strict equality check (`===`). */
areEqual = (value0, value1) => value0 === value1) {
    if (areEqual(value0, value1)) {
        return [];
    }
    else {
        return [
            value0,
            value1,
        ];
    }
}
const orderedValueDiffs = [
    (value0, value1) => {
        if (!isRunTimeType(value0, 'array') || !isRunTimeType(value1, 'array')) {
            return undefined;
        }
        return diffArrays(value0, value1);
    },
    (value0, value1) => {
        if (!isInstanceOf(value0, RegExp) || !isInstanceOf(value1, RegExp)) {
            return undefined;
        }
        /** Special case RegExps because they should be checked for equality as strings. */
        return diffBasic(value0, value1, (a, b) => String(a) === String(b));
    },
    (value0, value1) => {
        if (!isRunTimeType(value0, 'object') || !isRunTimeType(value1, 'object')) {
            return undefined;
        }
        return diffObjects(value0, value1);
    },
];
/**
 * Diff any values. For diffing objects, use `diffObjects` to get better types.
 *
 * @returns An empty tuple if the values are equal.
 */
export function diffValues(value0, value1) {
    let diffOutput = undefined;
    orderedValueDiffs.some((differ) => {
        diffOutput = differ(value0, value1);
        return !!diffOutput;
    });
    if (diffOutput) {
        return diffOutput;
    }
    /** Fallback to the basic diff. */
    return diffBasic(value0, value1);
}
